function [p3_cl_impulse_resp, p3_g_impulse_resp, p3_theta_iv, p3_r] = HS2018_SysID_final_p3_15819790()
close all
clc
%% --------------------------------------------------------------------- %%
%% System Identification Midterm Problem 3
%% --------------------------------------------------------------------- %%

%% My details
disp(' ');
disp('    ###########################################################')
disp('    #          SYSTEM IDENTIFICATION FINAL PROBLEM 3          #')
disp('    #              Student Name: Charlotte Moraldo            #')
disp('    #                Legi Number: 15-819-790                  #')
disp('    ###########################################################')
disp(' ');

%% --------------------------------------------------------------------- %%
%% PART 1 
%% --------------------------------------------------------------------- %%
disp(' ');
disp('#####################################################################')
disp('#                             PART 1:                               #')
disp('#    Design of experiments and estimation of the impulse response   #')
disp('#####################################################################')
disp(' ');

%% Initialization
Ts = 0.01;
N = 1024;
numTrain = 3;
numValid = 5-numTrain;
order = 8;

%% Build input signal and extract output
period_len = 2^order-1;
num_periods = floor(N/period_len);
r_base = idinput(period_len,'PRBS',[],[-1 1]);
r_per = [];

for i=1:num_periods
    r_per = [r_per; r_base];
end
r_sig = r_per;
for i=1:4
    r_sig = [r_sig,r_per];
end

y_sig = HS2018_SysID_final_p3_system_sim(15819790,r_sig);

%% Return Nx5 signal
p3_r = r_sig;    
    
%% Smooth ETFE by averaging (training set)
% Input
R = fft(r_base);
Ytrain = zeros(size(R,1),num_periods,numTrain);
Gtrain = zeros(size(R,1),1);
for train = 1:numTrain
    for nper = 1:(num_periods)
        Ytrain(:,nper,train) = fft(y_sig((nper-1)*period_len+1:(nper)*period_len,train));
        Gtrain = Gtrain + Ytrain(:,nper,train)./R;
    end
end
Gtrain_avg = Gtrain/(numTrain*num_periods);

%% Smooth ETFE by averaging (validation set)
Yvalid = zeros(size(R,1),num_periods,numValid);
Gvalid = 0;
for valid = (numTrain+1):5
    for nper = 1:(num_periods)
        Yvalid(:,nper,valid-numTrain) = fft(y_sig((nper-1)*period_len+1:(nper)*period_len,valid));
        Gvalid = Gvalid + Yvalid(:,nper,valid-numTrain)./R;
    end
end
Gvalid_avg = Gvalid/(numValid*num_periods);


%% Smooth ETFE by windowing
plot_index = 1;
N = size(Gtrain_avg,1);
R_tot = [];
for nper = 1:(num_periods)
    R_tot = [R_tot; R];
end 

mse_tab = [];
window_sizes = 1:1:200;
best_mse = 0;
cross_validation_mse = zeros(size(window_sizes));
Gs = zeros(length(Gtrain_avg),length(window_sizes));
best_Gs = zeros(length(Gtrain_avg),length(window_sizes));

for gamma_ind = 1:length(window_sizes)
    
    gamma = window_sizes(gamma_ind);
    
    % Generate frequency-domain Hann window with given gamma
    [freq_inds, freq_window] =  WfHann(gamma,period_len);
    freq_window = freq_window';
    
    % Shift window so that it starts at zero frequency (to line up with fft indices)
    zero_index = find(freq_inds == 0);
    freq_window = [freq_window(zero_index:end); freq_window(1:zero_index-1)];

    G_filt_num = zeros(period_len,1);
    G_filt_den = zeros(period_len,1);

    % Filter the ETFE estimate, using frequency-domain
    % windowing as on slide 4.17
    for freq = 1:period_len
        modified_freq_inds = mod((1:period_len) - freq,period_len)+1;
        % Calculate discretized integrals
        G_filt_num(freq,:) = sum(freq_window(modified_freq_inds).*abs(R).^2.*Gtrain_avg);
        G_filt_den(freq,:) = sum(freq_window(modified_freq_inds).*abs(R).^2);
    end

    % Compute filtered transfer function by averaging each period's filtered ETFE
    G_filt = G_filt_num./G_filt_den;
    G_filt_avg = mean(G_filt,2);
    
    % Store estimate to extract later
    Gs(:,gamma_ind) = G_filt_avg;
    
     % Compute MSE error
    cross_validation_error          = G_filt_avg-Gvalid_avg;
    cross_validation_mse(gamma_ind) = mean(cross_validation_error.*conj(cross_validation_error));
    
end
% Select best gamma
[~,best_gamma_ind] = min(cross_validation_mse);
best_gamma = window_sizes(best_gamma_ind);
best_Gs = Gs(:,best_gamma_ind);

%MSE curve
figure(1)
plot(window_sizes,cross_validation_mse,'linewidth',1); grid on;
xlabel('Window Size')
ylabel('MSE')
title('Mean Square Error depending on the window size')


%% Plots smoothed & windowed ETFE of training data and validation data
figure(2);
omega = (2*pi/size(Gtrain_avg(1:size(Gtrain_avg)/2+1),1))*...
         [0:size(Gtrain_avg(1:size(Gtrain_avg)/2+1),1)-1]';
     
loglog(1/Ts*omega,abs(Gtrain_avg(1:size(Gtrain_avg)/2+1))); grid on; hold on;
loglog(1/Ts*omega,abs(best_Gs(1:size(Gtrain_avg)/2+1)),'linewidth',1); hold on;
loglog(1/Ts*omega,abs(Gvalid_avg(1:size(Gtrain_avg)/2+1))); grid on; hold on;
xlabel('Frequency (rad/sec)')
ylabel('Amplitude of estimate')
legend('ETFE G_{cl}: computed with training data',...
       'ETFE G_{cl,windowed}: windowed G_{cl}',...
       'ETFE G_{cl,validation}: computed with validation data',...
       'Location','southwest');
title('Estimate of the closed-loop transfer function from r to y')


%% Impulse response
t = 0:Ts:(length(best_Gs)-1)*Ts;
impulse = ifft(best_Gs,'symmetric');
impulse_unsmoothed = ifft(Gtrain_avg,'symmetric');
impulse_n4sid = zeros(length(best_Gs));

% Subspace ID
data = iddata(y_sig(1:end,1),r_sig(1:end,1),Ts);
sys = n4sid(data,7);
A = sys.A; B = sys.B; C = sys.C; D = sys.D;
for k=1:length(best_Gs)
    if k==1
       impulse_n4sid(k) = D;
    else
       impulse_n4sid(k) = C*A.^(k-1)*B;
    end
end

figure(3)
plot(t,impulse_unsmoothed,'linewidth',1); grid on; hold on;
plot(t,impulse,'linewidth',1); grid on; hold on;
plot(t,impulse_n4sid(:,1),'linewidth',1); hold on; grid on;
xlim([0 2])
xlabel('Time (sec)')
ylabel('Amplitude of impulse response')
title('Impulse response of the closed-loop transfer function from r to y')
legend('Impulse response using the windowed ETFE G_{cl,windowed}',...
       'Impulse response using the unwindowed ETFE G_{cl}',...
       'Impulse response using subspace identification','Location','northeast')


%% Return desired impulse response
p3_cl_impulse_resp = impulse(1:200);

%% Documentation
explanation1 = [...
'In this exercise, we are asked to design a set of 5 experiments in total,\n'...
'each of maximum length 1024. I decided to design my inputs as a set of 5 \n'...
'identical 8-th order PRBS signals of amplitude +/- 1, for the following \n'...
'reasons:\n'...
'     > A PRBS signal excites the same way all the frequencies of the system, \n'...
'       which is very useful for identification properties. \n'...
'     > A PRBS signal is periodic, which helps reducing the transients. Using a \n'...
'       periodic input furthermore allows to compute unbiased ETFE (slide 3.15).\n'...
'     > Knowing that we have to return the impulse response of the closed-loop \n'...
'       transfer function over 2 seconds, and that the sampling time is \n'...
'       equal to T=0.01s, we can conclude that we have to return 200 samples. \n'...
'       The input signal should thus have a period length of minimum 200. \n'...
'       Furthermore, having more periods in the signal will allow to reduce \n'...
'       the variance accordingly and limit the effect of the noise when \n'...
'       averaging samples (slide 4.4). Knowing that a PRBS is periodic with \n'...
'       period equal to at most M = 2^x-1 (x its order), we can find that \n'...
'       for an 8-th order signal, the period length will be equal to 255. \n'...
'       This is the perfect tradeoff for our requirements, as it allows us \n'...
'       to use 4 entire periods (1020 points).\n'...
'     > The maximum allowed amplitude is +/- 1. In order to maximize the \n'...
'       signal to noise ratio, I therefore took this maximum amplitude and \n'...
'       set my PRBS amplitude of +/-1.\n'...
'\n'...
'Each of my 5 input signals are therefore constructed with 4 periods of an \n'...
'8-th order PRBS of amplitude +/-1. I then call the function HS2018_SysID_final_p3_system_sim \n'...
'with my Legi number and my 5 experiments, which outputs 5 output signals of \n'...
'the same length as the inputs (1020).\n'...
'I decided to split my output signal into a training set, and a validation \n'...
'set used for cross-validation. The training set contains the first 3 output \n'...
'signals (3x4 = 12 periods in total), and the validation set contains the \n'...
'2 remaining signals (2x4 = 8 periods in total). More details concerning this \n'...
'choice will come later. \n'...
'\n'...
'I then computed the ETFE (Empirical Transfer Function Estimate) of the system \n'...
'both with the training and the validation set, and smoothed it by averaging.\n'...
'For each of the 12 periods in the training set, I computed the FFT (Fast \n'...
'Fourier Transform) Y of y(k), R of r(k), and found the ETFE G_cl by doing \n'...
'Y/R. I then averaged G_cl over all the 12 periods. The exact same protocol \n'...
'was performed with the validation set, resulting in the estimate G_cl_validation.\n'...
'The ETFEs are therefore of size one period (length = 255).\n'...
'Averaging the signal allows to smooth the ETFE (slide 4.14), as well as to \n'...
'reduce as much as possible the effect of the noise, reducing the variance\n'...
'at the same time. \n'...
'\n'...
'In order to minimize the effect of transients, I could have thrown away the\n'...
'first period and only average over 3 periods. However, throwing away so much \n'...
'data samples is undesirable. I computed the number of unused data samples, \n'...
'equal to 4 in my case (1024 total points - 4 periods*255). Instead of taking \n'...
'the first 4 periods and discarding the remaining points, I counted 4 periods\n'...
'starting from the end of the data and discarded the first 4 points. I know\n'...
'that 4 points isnt much, but it is in my opinion the best tradeoff between \n'...
'reducing transient effect and keeping as much data samples as possible.\n'...
'\n'...
'In order to smooth the ETFE even further and reduce the effect of the noise, \n'...
'I decided to apply a frequency-domain Hann window to my closed-loop ETFE G_cl,\n'...
'as on slide 4.17. To do so, I used the provided function WfHann. In order to\n'...
'find a good tradeoff between bias and variance, the optimal window width has \n'...
'to be found. Usually, we would compute the Mean Square Error (MSE) between\n'...
'the windowed G_cl and the real plant G, and find the gamma that minimizes \n'...
'the MSE. However, in our case, we do not have access to real plant. This is \n'...
'why I used a validation set. I compute the MSE between the windowed G_cl and \n'...
'the G_cl_validation, and then find the window width which minimizes it.\n'... 
'Figure 1 shows how the MSE varies with the window size. We can see that it\n'...
'isnt easy to determine which gamma is optimal, as at some point the MSE \n'...
'curve becomes very flat. The result obtained is however the following: the \n'...
'optimal gamma is given by: \n'...
'                       gamma_opt = ',num2str(best_gamma),'.\n'... 
'\n'... 
'Figure 2 plots the frequency response of the ETFEs G_cl (computed over\n'... 
'the training data), G_cl_validation (computed over the validation data),\n'... 
'and the windowed ETFE G_cl_windowed (training data).\n'... 
'\n'... 
'Finally, it is possible to compute the impulse response of the closed loop \n'... 
'transfer function. The simplest way to do so is to take the inverse FFT of \n'... 
'G_cl_windowed. This can be done using the Matlab command ifft.\n'... 
'Another way to compute the impulse response is by performing subspace \n'... 
'identification, as explained on slide 7.2: by evaluating the state-space\n'... 
'matrices A, B, C and D, the pulse response can be computed. I considered \n'... 
'that computing myself the entire algorithm for subspace identification was \n'... 
'out of the scope of this exercise. The Matlab function n4sid however \n'... 
'implements this for us and estimates an nx-order state-space model using \n'... 
'subspace methods. In order to cross-validate my result obtained with the ifft, \n'... 
'I therefore used n4sid to compute a subspace ID impulse response. After \n'... 
'trying different order values, I decided to set the order of the model to nx = 7.\n'... 
'\n'... 
'Figure 3 plots the impulse response of the closed loop transfer \n'... 
'function:\n'... 
'     > impulse response calculated with the windowed ETFE G_cl_windowed\n'... 
'     > impulse response calculated with the unwindowed ETFE G_cl\n'...  
'     > impulse response calculated with subspace identification\n'... 
'\n'... 
'We can see how well the windowing smooths the result. The impulse response \n'... 
'calculated with the unwindowed ETFE still contains a lot of noise. Finally, \n'... 
'the impulse response obtained with subspace identification confirms our \n'... 
'results.\n'...
'The impulse response returned in p3_cl_impulse_resp corresponds to the impulse\n'...
'response computed with the windowed ETFE of the closed-loop system.\n' ];
fprintf(explanation1);
disp(' ');

%% --------------------------------------------------------------------- %%
%% PART 2 
%% --------------------------------------------------------------------- %%
disp(' ');
disp('#####################################################################')
disp('#                             PART 2:                               #')
disp('#                    Discrete-time controller                       #')
disp('#####################################################################')
disp(' ');

%% 2.i
disp(' ');
disp('    ###########################################################')
disp('    #                i. Impulse response of G                 #')
disp('    ###########################################################')
disp(' ');

%% Define C(z)
w = [0:length(best_Gs)-1].*(2*pi/length(best_Gs));
Cz = tf([10 -9.01],[1 -0.9802],Ts);
Cz_pts = squeeze(freqresp(Cz, w/Ts));

%% Compute G(z)
G_unsmoothed = Gtrain_avg./(Cz_pts.*(ones(length(Gtrain_avg),1)-Gtrain_avg));
G = best_Gs./(Cz_pts.*(ones(length(best_Gs),1)-best_Gs));


%% Impulse response
impulseG = ifft(G,'symmetric');
impulseG_unsmoothed = ifft(G_unsmoothed,'symmetric');

figure(4)
plot(t,impulseG_unsmoothed,'linewidth',1); hold on
plot(t,impulseG,'linewidth',1); grid on
xlim([0 2])
xlabel('Time (sec)')
ylabel('Amplitude of impulse response')
title('Impulse response of G(z)')
legend('Impulse response of G(z) using unwindowed closed-loop transfer function',...
       'Impulse response of G(z) using windowed closed-loop transfer function',...
       'Location','northeast')
   
%% Return desired impulse response
p3_g_impulse_resp = impulseG_unsmoothed(1:200);

%% Documentation
explanation2 = [...
'Similarly as what is done in the slide 8.10, given the model drawn at the \n'...
'beginning of exercise 3, we can write that the closed-loop transfer function \n'...
'estimated in part 1 is given by:\n'...
'\n'...
'\n'...
'            G*C                                                     10z - 9.01\n'...
' G_cl =  ---------  where G is what we are looking for, and  C  =  ---------------\n'...
'          1 + G*C                                                   z - 0.9802\n'...
'\n'...
'                                                                        G_cl\n'...
'By working mathematically this formula, we can derive that:  G  =  ----------------\n'...
'                                                                     C*( 1 - G_cl)    \n'...           
'\n'...
'\n'...
'Before being able to compute the frequency response of G, we must also first \n'...
'compute the frequency response of C, since it is given as a transfer function. \n'...
'This is done with the following: C_freq = squeeze(freqresp(C, w)). C is \n'...
'defined as shown above, and w is a vector of the same size as G_cl (255 \n'...
'samples) equally distributed between 0 and 2*pi/Ts.\n'...
'\n'...
'Once this is done, we can compute G as shown above. There, two possibilities \n'...
'appear:\n'...
'     > Use G_cl, the unwindowed ETFE of the closed-loop transfer function\n'...
'     > Use G_cl_windowed, the windowed ETFE of the closed-loop transfer function\n'...
'\n'...
'For now, I will keep both possibilities and compute the impulse response \n'...
'for both cases. Similarly as in part 1, I do so by taking the inverse FFT \n'...
'of G. The results are plotted in figure 4. We can see that the windowed plot\n'...
'is more smooth than the unwindowed one, but it is however highly biased. This \n'...
'could be expected, as frequency-domain windowing introduces bias. The \n'...
'wider the frequency window (gamma smaller), the higher the bias (slide 4.18). \n'...
'Therefore, as a precaution, I decided to return in p3_g_impulse_resp the \n'...
'impulse response corresponding to the one computed with the unwindowed ETFE G_cl.\n'...
'\n' ];
fprintf(explanation2);
disp(' ');


%% 2.ii
disp(' ');
disp('    ###########################################################')
disp('    #                        ii. Bias                         #')
disp('    ###########################################################')
disp(' ');


%% Documentation
explanation3 = [...
'In order to obtain the estimate G, as seen above, we divide G_cl by \n'...
'C*( 1 - G_cl ). However, we have seen in class (cf. slide 8.12) that even \n'...
'if two estimates may be unbiased, their ratio isnt. Therefore, we can \n'...
'conclude that the estimate G is biased.\n'...
];
fprintf(explanation3);


%% --------------------------------------------------------------------- %%
%% PART 3
%% --------------------------------------------------------------------- %%
disp(' ');
disp('#####################################################################')
disp('#                             PART 3:                               #')
disp('#                      Instrumental Variables                       #')
disp('#####################################################################')
disp(' ');

regN = 200;
sigN = num_periods*period_len;
t = 0:Ts:(sigN-1)*Ts;
t_regN = 0:Ts:(regN-1)*Ts;
theta = zeros(regN,5);
theta_avg = zeros(regN,1);

figure(5)
for exp=1:5
    % Estimate u
    u = lsim(Cz,(r_per-y_sig(:,exp)),t);

    % Build regressor and VI
    phi = toeplitz(u);
    xsi = toeplitz(r_per);
    phi(:,regN+1:end) = [];
    xsi(:,regN+1:end) = [];

    for i=1:regN
        for j=1:regN
            if i<j
                phi(i,j) = 0;
                xsi(i,j) = 0;
            end
        end
    end
    theta(:,exp) = (xsi.'*phi)\(xsi.'*y_sig(:,exp));
    plot(t_regN,theta(:,exp),'--'); grid on; hold on;
    theta_avg = theta_avg + theta(:,exp);
end
theta_avg = theta_avg/5;
plot(t_regN,theta_avg,'b','linewidth',1); hold on;
xlim([0 2])
xlabel('Time (sec)')
ylabel('Amplitude of impulse response')
title('Instrumental Variable Impulse Response')
legend('Estimated theta from output 1',...
       'Estimated theta from output 2',...
       'Estimated theta from output 3',...
       'Estimated theta from output 4',...
       'Estimated theta from output 5',...
       'Averaged estimated theta','Location','northeast');


%% Return desired impulse response
p3_theta_iv = theta_avg;


%% Documentation

% 3.i
disp(' ');
disp('    ###########################################################')
disp('    #         i. Choice of instrumental variables             #')
disp('    ###########################################################')
disp(' ');
explanation4 = [...
'The hints in the instructions say that: "the instrumental variables should \n'...
'be chosen from r at particular timesteps".\n'...
'\n'...
'We know that if the noise and the instruments are correlated, then \n'...
'we lose consistency - meaning that we dont get asymptotically unbiased \n'...
'(slide 11.35). We have to be careful with that since it can happen in \n'...
'closed-loop configurations. For example, generating instruments from u \n'...
'will induce correlation between instruments and noise. \n'...
'Keeping the hint in mind, I therefore decide to generate my instrumental \n'...
'variables from the excitation r, which is recommended in closed-loop \n'...
'configurations as said on slide 11.35.\n'...
'\n'...
'Therefore, we can write that the instrumental variables are given by:\n'...
'           zeta(k) = [ r(k)  r(k-1)  r(k-2)  ...  r(k-M+1)]\n'...
'\n'...
'Since we only want to estimate theta_IV = [h1, ..., h200], the first \n'...
'200 samples of the impulse response of G, then M is equal to 200 and \n'...
'therefore:\n'...
'           zeta(k) = [ r(k)  r(k-1)  r(k-2)  ...  r(k-199)]\n'...
'\n'...
];
fprintf(explanation4);
disp(' ');

% 3.ii
disp(' ');
disp('    ###########################################################')
disp('    #               ii. Building the regressor                #')
disp('    ###########################################################')
disp(' ');
explanation5 = [...
'The hints in the instructions say that: "the regressors should be chosen \n'...
'from u at particular timestep, and note that u can be computed from the \n'...
'experimental y and r data, as well as the given C(z) and the closed-loop \n'...
'equations".\n'...
'\n'...
'When looking at the closed-loop model drawn at the beginning of problem 3,\n'...
'and setting v(k) to zero, we can write that:\n'...
'\n'...
'y(k) = convolution( u(k),G )\n'...
'     = sum ( g(l)*u(k-l) )     where the sum goes from l=0 to M=199.\n'...
'\n'...
'By expanding this, we obtain:\n'...
'\n'...
'y(k) = g(0)*u(k) + g(1)*u(k-1) + ... + g(199)*u(k-199)\n'...
'     = [u(k)  u(k-1)  ...  u(k-199) ] * [g(0)  g(1)  ...  g(199)]^T\n'...
'\n'...
'Therefore, the regressor that will be used to determine the estimate is:\n'...
'\n'...
'phi(k) = [u(k)  u(k-1)  ...  u(k-199) ]\n'...
'\n'...
'Which is in line with what the hint is saying.\n'...
'\n'...
];
fprintf(explanation5);


% 3.iii
disp(' ');
disp('    ###########################################################')
disp('    #            iii. Determining the estimate                #')
disp('    ###########################################################')
disp(' ');
explanation6 = [...
'In order to build the regressor phi(k), we must firstly estimate u(k). As \n'...
'suggested by the hint, this can be done by using the experimental y and r \n'...
'data, as well as the given C(z). Indeed, u(k) can be written as: \n'...
'u = C(z)*(r - y). This can simply be computed in Matlab using lsim.\n'...
'\n'...
'The instrumental variable methods finds the estimate of theta by solving:\n'...
'\n'...
'theta_IV = ( 1/K * sum[zeta(k)*phi(k)^T] )^(-1)   *   1/K * sum[zeta(k)*y(k)]\n'...
'\n'...
'Where phi(k) is the regressor and zeta(k) is the instrumental variable at \n'...
'index k. This formula can be written in matrix form, but to do so, lets \n'...
'define the matrix Zeta, where each row contains zeta(k) for k going from \n'...
'0 to N-1 (N is the length of the data: N = 4 periods * length of 255 = 1020). \n'...
'Zeta is therefore of dimension Nx200 and looks like the following:\n'...
'\n'...
'Zeta = [ zeta(1)  zeta(2)  ...  zeta(N) ]^T\n'...
'\n'...
'     = [r(0)    r(-1)    r(-2)   ...  r(-200) ;\n'...
'        r(1)    r(0)     r(-1)   ...  r(-199) ;\n'...
'        ...     ...      ...     ...    ...   ;\n'...
'        r(N)   r(N-1)   r(N-2)   ...  r(N-200)]\n'...
'\n'...
'Since we know from the instructions that r(k) = 0 for k < 0, then:\n'...
'\n'...
'Zeta  = [r(0)       0        0      ...      0   ;\n'...
'         r(1)      r(0)      0      ...      0   ;\n'...
'         ...       ...      ...     ...     ...  ;\n'...
'         r(200)   r(199)   r(198)   ...     r(0) ;\n'...
'         r(201)   r(200)   r(199)   ...     r(1) ;\n'...
'          ...      ...      ...     ...     ...\n'...
'         r(N)     r(N-1)   r(N-2)   ...   r(N-200)]\n'...
'\n'...
'The exact same procedure can be done with the regressor phi(k): we define \n'...
'the Nx200 matrix Phi which has the same form as Zeta. \n'...
'Zeta and Phi can be thought of as a NxN Toeplitz matrix, whose upper \n'...
'triangular elements are equal to zero, and who is then truncated into \n'...
'an Nx200 matrix.\n'...
'\n'...
'The equation to find the 200 first estimates of theta can now be written\n'...
'in the following matrix form:\n'...
'\n'...
'            theta_IV = (Zeta^T * Phi)^(-1) * Zeta.^2 * Y\n'...
'\n'...
'Where Y = [y(1)  y(2)  ...  y(N)]^T, an Nx1 vector. By working out the \n'...
'dimensions of this matrix-form equation, we can verify that theta_IV will \n'...
'be a vector of dimension 200x1, which is what is desired.\n'...
'\n'...
'Lets recall that we have 5 different outputs available from the experiment. \n'...
'However, this method only takes one output Y of size Nx1 into account. \n'...
'Therefore, I decided to compute the instrumental variable method 5 times, \n'...
'for each output signal. The resulting estimated parameters are plotted in \n'...
'figure 5 with the dotted lines. In order to take into account all the \n'...
'information received from the experiment, I averaged these 5 estimations \n'...
'and obtained the final estimated theta, returned in the variable p3_theta_iv \n'...
'(full line on fig. 5). \n'...
'\n'...
];
fprintf(explanation6);


%% Comparison IV and G
figure(6)
plot(t_regN,theta_avg,'linewidth',1); hold on; grid on;
plot(t_regN,impulseG_unsmoothed(1:200),'linewidth',1); grid on
xlim([0 2])
xlabel('Time (sec)')
ylabel('Amplitude of impulse response')
title('Impulse Response of G')
legend('Impulse Response of G estimated with Instrumental Variables',...
       'Impulse Response of G estimated with Indirect Closed-Loop Identification Methods',...
       'Location','northeast')

%% Documentation
disp(' ');
explanation7 = [...
'To finish, lets have a look at one last graph (figure 6). It contains the\n'...
'plots of the impulse response of G using different methods: indirect\n'...
'closed-loop identification, and instrumental variables. We can see that the\n'...
'results are close, but the indirect CL method gives a slightly biased response\n'...
'over the whole length of the signal. This comes from the same reason as explained\n'...
'in part 2.ii of this exercise (slide 8.12), and confirms the deduction that G is\n'...
'biased.\n'...
];
fprintf(explanation7);

end
